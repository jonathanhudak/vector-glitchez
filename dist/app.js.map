{
  "version": 3,
  "sources": ["../node_modules/powerglitch/lib/index.js", "../src/app.js"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PowerGlitch = void 0;\n/**\n * Get best-looking default options for most images.\n */\nconst getDefaultOptions = () => ({\n    backgroundColor: 'transparent',\n    hideOverflow: false,\n    timing: {\n        duration: 2 * 1000,\n        iterations: Infinity,\n    },\n    glitchTimeSpan: {\n        start: 0.5,\n        end: 0.7,\n    },\n    shake: {\n        velocity: 15,\n        amplitudeX: 0.4,\n        amplitudeY: 0.4,\n    },\n    slice: {\n        count: 6,\n        velocity: 15,\n        minHeight: 0.02,\n        maxHeight: 0.15,\n        hueRotate: true,\n    },\n});\n/**\n * Get a random value between -1 and 1, which biases towards the center if the animation should not glitch at the given `stepPct` moment.\n */\nconst getGlitchRandom = (options, stepPct) => {\n    // Get glitch factor for this step\n    let glitchFactor = 0;\n    if (options.glitchTimeSpan) {\n        const glitchStart = options.glitchTimeSpan.start;\n        const glitchEnd = options.glitchTimeSpan.end;\n        if (stepPct < glitchStart || stepPct > glitchEnd) {\n            return 0;\n        }\n        const glitchPeak = glitchStart + (glitchEnd - glitchStart) / 2;\n        if (stepPct < glitchPeak) {\n            glitchFactor = (stepPct - glitchStart) / (glitchPeak - glitchStart);\n        }\n        else {\n            glitchFactor = (glitchEnd - stepPct) / (glitchEnd - glitchPeak);\n        }\n    }\n    else {\n        glitchFactor = 1;\n    }\n    // Apply glitch factor to a uniform random value between -1 and 1\n    const rand = (Math.random() - .5) * 2;\n    return rand * glitchFactor;\n};\n/**\n * Get a random rectangle values in % to glitch. Percent values are between 0 and 100.\n * @param minHeight Minimum height of the rectangle in percent, between 0 and 1.\n * @param maxHeight Maximum height of the rectangle in percent, between 0 and 1.\n * @param minWidth Minimum width of the rectangle in percent, between 0 and 1.\n * @param maxWidth Maximum width of the rectangle in percent, between 0 and 1.\n */\nconst getRandomRectangle = ({ minHeight, maxHeight, minWidth, maxWidth }) => {\n    // Choose a random size for this rectangle\n    const height = Math.floor(Math.random() * ((maxHeight - minHeight) * 100 + 1)) + minHeight * 100;\n    const width = Math.floor(Math.random() * ((maxWidth - minWidth) * 100 + 1)) + minWidth * 100;\n    // Put this rectangle somewhere in the container so that it does not go out of the screen.\n    const top = Math.floor(Math.random() * (100 - height));\n    const left = Math.floor(Math.random() * (100 - width));\n    // Get value as a CSS polygon\n    return { top, left, height, width };\n};\n/**\n * Transform a rectangle into a CSS polygon.\n * @param rectangle Rectangle to transform.\n */\nconst getRectanglePolygonCss = ({ top, left, height, width }) => {\n    const topRight = `${left + width}% ${top}%`;\n    const bottomRight = `${left + width}% ${top + height}%`;\n    const bottomLeft = `${left}% ${top + height}%`;\n    const topLeft = `${left}% ${top}%`;\n    return `polygon(${topRight}, ${bottomRight}, ${bottomLeft}, ${topLeft})`;\n};\n/**\n * Get default timing function, which makes sequential changes without transition.\n * @param stepCount Number of steps in the animation\n */\nconst getDefaultTimingCss = (stepCount) => {\n    return Object.assign(Object.assign({}, getDefaultOptions().timing), { easing: `steps(${stepCount}, jump-start)` });\n};\n/**\n * Generate a slice layer, slicing part of the image and moving it somwhere else.\n * @param options\n */\nconst generateGlitchSliceLayer = (options) => {\n    if (!options.slice) {\n        throw new Error('Slice are not enabled');\n    }\n    const stepCount = Math.floor(options.slice.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for (let index = 0; index < stepCount; ++index) {\n        const rectangle = getRandomRectangle({ minHeight: options.slice.minHeight, maxHeight: options.slice.maxHeight, minWidth: 1, maxWidth: 1 });\n        const translateX = getGlitchRandom(options, index / stepCount) * 30;\n        const styles = {};\n        styles.transform = `translate3d(${translateX}%, 0, 0)`;\n        styles.clipPath = getRectanglePolygonCss(rectangle);\n        if (options.slice.hueRotate) {\n            styles.filter = `hue-rotate(${Math.floor(getGlitchRandom(options, index / stepCount) * 360)}deg)`;\n        }\n        steps.push(styles);\n    }\n    return { steps, timing: Object.assign(Object.assign({}, getDefaultTimingCss(stepCount)), options.timing) };\n};\n/**\n * Generate the base layer, which may or may not shake depending on the options.\n * @param options\n */\nconst generateBaseLayer = (options) => {\n    if (!options.shake) {\n        return { steps: [], timing: getDefaultTimingCss(1) };\n    }\n    const stepCount = Math.floor(options.shake.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for (let index = 0; index < stepCount; ++index) {\n        const translateX = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeX * 100;\n        const translateY = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeY * 100;\n        const styles = {};\n        styles.transform = `translate3d(${translateX}%, ${translateY}%, 0)`;\n        steps.push(styles);\n    }\n    return { steps, timing: Object.assign(Object.assign({}, getDefaultTimingCss(stepCount)), options.timing) };\n};\n/**\n * Generate all layers\n * @param options\n */\nconst generateLayers = (options) => {\n    const layers = [];\n    layers.push(generateBaseLayer(options));\n    if (options.slice) {\n        for (let i = 0; i < options.slice.count; ++i) {\n            layers.push(generateGlitchSliceLayer(options));\n        }\n    }\n    return layers;\n};\n/**\n * Animate a given div with a given set of layers, showing the specified image.\n * @param div\n * @param layers\n * @param options\n * @param imageUrl\n */\nconst animateDiv = (div, layers, options, imageUrl) => {\n    const templateLayer = document.createElement('div');\n    templateLayer.classList.add('layer');\n    templateLayer.style.backgroundColor = options.backgroundColor;\n    templateLayer.style.backgroundRepeat = 'no-repeat';\n    templateLayer.style.backgroundPosition = 'center';\n    templateLayer.style.backgroundSize = 'contain';\n    templateLayer.style.width = '100%';\n    templateLayer.style.height = '100%';\n    templateLayer.style.top = '0';\n    templateLayer.style.left = '0';\n    templateLayer.style.position = 'absolute';\n    // Empty & init. div style\n    div.style.position = 'relative';\n    if (options.hideOverflow) {\n        div.style.overflow = 'hidden';\n    }\n    else {\n        div.style.overflow = 'visible';\n    }\n    while (div.firstChild) {\n        div.removeChild(div.firstChild);\n    }\n    // For each animation layer, clone template layer, tweak styles, and append to element\n    for (const layer of layers) {\n        const layerDiv = templateLayer.cloneNode(false);\n        layerDiv.style.backgroundImage = `url(${imageUrl})`;\n        layerDiv.animate(layer.steps, layer.timing);\n        div.appendChild(layerDiv);\n    }\n};\n/**\n* Performs a deep merge of objects and returns new object. Does not modify\n* objects (immutable) and merges arrays via concatenation.\n* @param objects - Objects to merge\n* @returns New object with merged key/values\n*/\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction mergeDeep(...objects) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const isObject = (obj) => obj && typeof obj === 'object';\n    return objects.reduce((prev, obj) => {\n        Object.keys(obj)\n            .forEach(key => {\n            const pVal = prev[key];\n            const oVal = obj[key];\n            if (Array.isArray(pVal) && Array.isArray(oVal)) {\n                prev[key] = pVal.concat(...oVal);\n                return;\n            }\n            if (isObject(pVal) && isObject(oVal)) {\n                prev[key] = mergeDeep(pVal, oVal);\n                return;\n            }\n            if (oVal !== undefined) {\n                prev[key] = oVal;\n            }\n        });\n        return prev;\n    }, {});\n}\n/**\n * Make a single element glitch.\n * @param elOrSelector Element or selector to glitch.\n * @param userOptions Options for the glitch.\n */\nconst glitch = (elOrSelector = '.powerglitch', userOptions = {}) => {\n    // Fix options with defaults\n    const options = mergeDeep(getDefaultOptions(), userOptions);\n    // Find elements to glitch\n    let elements = [];\n    if (typeof elOrSelector === 'string') {\n        const foundElements = document.querySelectorAll(elOrSelector);\n        if (!foundElements.length) {\n            throw new Error(`Could not find any element with selector ${elOrSelector}`);\n        }\n        elements = Array.from(foundElements);\n    }\n    else {\n        elements = [elOrSelector];\n    }\n    // Discriminate between img and div for code simplicity\n    const imgElements = elements.filter(el => el instanceof HTMLImageElement);\n    const divElements = elements.filter(el => el instanceof HTMLDivElement);\n    // Generate all animation layers\n    const layers = generateLayers(options);\n    // Animate each image element\n    for (const imgElement of imgElements) {\n        const newContainer = document.createElement('div');\n        newContainer.style.width = imgElement.clientWidth + 'px';\n        newContainer.style.height = imgElement.clientHeight + 'px';\n        if (!imgElement.parentElement) {\n            throw new Error('Unable to glitch image, it is not attached to a parent element');\n        }\n        imgElement.parentElement.insertBefore(newContainer, imgElement);\n        // Keep but hide the image, to avoid breaking the original application\n        imgElement.style.display = 'none';\n        // Animate the new container\n        animateDiv(newContainer, layers, options, options.imageUrl || imgElement.src);\n    }\n    // Animate each div element\n    for (const divElement of divElements) {\n        // If options.imageUrl was not set, we do not know what src to use to glitch this div\n        if (!options.imageUrl) {\n            throw new Error('Options.imageUrl must be set if there are div elements to glitch');\n        }\n        animateDiv(divElement, layers, options, options.imageUrl);\n    }\n};\nexports.PowerGlitch = {\n    glitch,\n    generateLayers,\n    getDefaultOptions,\n};\n", "import { PowerGlitch } from \"powerglitch\";\n\nPowerGlitch.glitch(\".glitch-1\", {\n  timing: {\n    duration: 1500,\n    iterations: 15,\n  },\n  glitchTimeSpan: {\n    start: 0.4,\n    end: 0.7,\n  },\n  shake: {\n    velocity: 10,\n    amplitudeX: 0.4,\n    amplitudeY: 0.4,\n  },\n  slice: {\n    count: 4,\n    velocity: 10,\n    minHeight: 0.02,\n    maxHeight: 0.4,\n    hueRotate: true,\n  },\n});\nPowerGlitch.glitch(\".glitch-2\", {\n  timing: {\n    duration: 1500,\n    iterations: 15,\n  },\n  glitchTimeSpan: {\n    start: 0.4,\n    end: 0.7,\n  },\n  shake: {\n    velocity: 10,\n    amplitudeX: 0.4,\n    amplitudeY: 0.4,\n  },\n  slice: {\n    count: 4,\n    velocity: 10,\n    minHeight: 0.02,\n    maxHeight: 0.4,\n    hueRotate: true,\n  },\n});\n\nPowerGlitch.glitch(\".glitch-3\", {\n  timing: {\n    duration: 2000,\n    iterations: 15,\n  },\n  glitchTimeSpan: {\n    start: 0.4,\n    end: 0.7,\n  },\n  shake: {\n    velocity: 10,\n    amplitudeX: 0.4,\n    amplitudeY: 0.4,\n  },\n  slice: {\n    count: 4,\n    velocity: 10,\n    minHeight: 0.02,\n    maxHeight: 0.4,\n    hueRotate: true,\n  },\n});\n\nconsole.log(\"hello hello\");\n"],
  "mappings": "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",
  "names": ["require_lib", "__commonJSMin", "exports", "getDefaultOptions", "getGlitchRandom", "options", "stepPct", "glitchFactor", "glitchStart", "glitchEnd", "glitchPeak", "getRandomRectangle", "minHeight", "maxHeight", "minWidth", "maxWidth", "height", "width", "top", "left", "getRectanglePolygonCss", "topRight", "bottomRight", "bottomLeft", "topLeft", "getDefaultTimingCss", "stepCount", "generateGlitchSliceLayer", "steps", "index", "rectangle", "translateX", "styles", "generateBaseLayer", "translateY", "generateLayers", "layers", "animateDiv", "div", "imageUrl", "templateLayer", "layer", "layerDiv", "mergeDeep", "objects", "isObject", "obj", "prev", "key", "pVal", "oVal", "glitch", "elOrSelector", "userOptions", "elements", "foundElements", "imgElements", "el", "divElements", "imgElement", "newContainer", "divElement", "import_powerglitch"]
}
